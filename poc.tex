\chapter{Solución propuesta}
\label{chap:poc}

Para nuestro trabajo utilizaremos las librerías SEAL (como representante de la segunda generación) y THFE (como representante de la tercera). Comenzaremos con un estudio del funcionamiento de las librerías, de cuales son sus límites computacionales y pienso una operación que no sea "trivial" y a la vez sea computable por ambos.

La librería SEAL cuenta con pocas operaciones aritméticas implementadas, pero ofrece la posibilidad de trabajar con matrices y números decimales. La principal complicación con SEAL es determinar cómo se está desviando el cálculo para saber cuándo parar o qué correcciones hacer. Además, las operaciones que puede hacer son relativamente limitadas (cuando se hacen, por ejemplo productos, crece mucho el error). Además, el algoritmo que se implemente en SEAL no puede contener más que sumas, restas y multiplicaciones (no existe la división).

La librería TFHE ofrece una API de operaciones lógicas a nivel de bit. Aunque permitirá hacer cálculos más complejos sin añadir error al resultado, tendremos que implementar todas las operaciones a bajo nivel mediante puertas lógicas, siempre teniendo en cuenta que en ningún momento vamos a poder controlar el flujo de ejecución y nuestros algoritmos tienen que ser capaces de realizar los cálculos sin poder evaluar las variables (están cifradas).

Por lo tanto tenemos que encontrar un cálculo que sea realizable con pocas operaciones y números bajos para SEAL; y operaciones que sean implementables en un tiempo razonable con puertas lógicas para poder trabajar en TFHE.

Se han elegido tanto el sistema de ejemplo como las tecnologías específicas para cada uno de los actores en función de las capacidades y limitaciones de cada tecnología. Como resultado del proyecto se ha creado, además del análisis y el propio código del proyecto, una librería de operaciones matemáticas implementadas en TFHE (\cite{junquera_tfhe_2019}) con puertas lógicas, que es innovadora en tanto en cuanto no existe ningún código público que permita trabajar con TFHE a este nivel.

\section{Funcionamiento del sistema}

Para analizar las librerías implementaremos un sistema de posicionamiento anónimo en función de la temperatura y el mes del año. La base para determinar la posición serán dos curvas de regresión cuadrática de temperaturas de dos ciudades (generada con TFHE), que permitirá que un usuario suba a SEAL la fecha y la temperatura cifradas y averigüe su localización.

En este sistema habrá tres actores: el cliente, el servidor de posicionamiento (programado con SEAL) y un tercer servidor (programado con TFHE) que generará el modelo para calcular la posición. El cliente consultará su posición con el servidor de SEAL, que previamente habrá generado en el servidor de TFHE un modelo de posicionamiento basado en las temperaturas del último año en varias ubicaciones (ver \ref{fig:sistema_completo}).

Generaremos dicho modelo (la curva de regresión $f(x)$) con TFHE porque para ello necesitaremos realizar operaciones aritméticas que no nos ofrece SEAL. De esta forma, podremos realizar la evaluación de los datos introducidos por el usuario con SEAL (distancia entre el valor de temperatura $y$ especificado por el usuario, y $f(x)$ con $x$ el mes del año) utilizando sus operaciones más básicas, y aprovechando su sistema de vectores para evaluar todas las curvas al mismo tiempo.

\begin{figure}[h]
    \caption{Flujo de los datos cifrados\footnote{Diagrama generado con Piktochart \url{https://piktochart.com}}}
    \label{fig:sistema_completo}
    \includegraphics[width=\linewidth]{sistema_completo}
\end{figure}

\subsection{Generación del modelo}

Para generar el modelo el cliente (en este caso, el servidor de posicionamiento con SEAL) y el servidor (el servidor con TFHE) seguirían el siguiente procedimiento:

\begin{enumerate}
    \item El cliente genera un par de claves (pública y privada).

    \item Cifra $n$ pares de datos (en nuestro ejemplo el par sería $(mes, temperatura)$).

    \item Sube los datos cifrados y su clave pública. El número de datos que se puede subir está limitado por el crecimiento del tamaño (en bits) de dichos datos al exponenciarlos para calcular la curva de regresión. Trabajaremos con los datos de 12 meses porque, como comentaremos más adelante\ref{chap:resultados}, aunque el orden máximo al que llegaríamos con estos datos es de 46 bits tendremos otras limitaciones a la hora de procesar los datos.

    \item El servidor procesa los datos y devuelve cifrados los parámetros de la curva

    \item El cliente los descifra y los almacena asociados a una posición geográfica
\end{enumerate}

Finalmente, con los parámetros recibidos, el cliente obtendría una curva similar a \ref{fig:reg2_cg}.

\begin{figure}[h]
    \caption{Curva de Regresión Cuadrática con temperaturas de Cabo de Gata}
    \label{fig:reg2_cg}
    \includegraphics[width=\linewidth]{reg2_cg}
\end{figure}

\subsection{Obtención de la posición}

Teniendo el servidor de SEAL ya generados los modelos de la temperatura de cada ubicación (en este caso, sólo los 2 de Cabo de Gata y Finisterre) el cliente (ahora ya sí, el usuario final) consultará su ubicación:

\begin{enumerate}

  \item El cliente genera tres claves: pública, privada y clave de realinearización.

  \item El cliente cifra (con su clave pública) la temperatura y el mes del año para el que quiere hacer la consulta, generando los valores $y$ e $x$ respectivamente.

  \item Sube ambos valores al servidor, junto con la clave de realinearización (en nuestro ejemplo, no se necesitará subir la pública).

  \item El servidor calculará la diferencia (resta) entre el punto $y$ y $f(x)$ para cada curva

  \item El servidor devuelve una lista con los valores calculados y la ubicación a la que corresponde cada valor

  \item El cliente descifra los valores con su clave privada, obteniendo la distancia entre la temperatura introducida y el valor de la curva de cada una de las ubicaciones ese mes.

\end{enumerate}

En la figura \ref{fig:t_vs_r2} se puede ver un ejemplo del funcionamiento del sistema de posicionamiento. Los puntos introducidos corresponden a las temperaturas de varias ubicaciones, y el sistema de posicionamiento devolvería la distancia entre estos puntos y las dos curvas de regresión. De esta forma se puede obtener una estimación de la posición. En el ejemplo vemos que, la temperatura en Cabo de Gata está muy próxima a su curva en el mes de junio, y daría un resultado indeterminado en abril; que la temperatura de Madrid no casaría con ninguna de las dos curvas; o que la temperatura de Finisterre en noviembre efectivamente está mucho más cerca de la curva de Finisterre que de la de Cabo de Gata.

\begin{figure}[h]
    \caption{Temperatura vs Regresión}
    \label{fig:t_vs_r2}
    \includegraphics[width=\linewidth]{t_vs_r2}
\end{figure}

\section{Implementación con TFHE}

Para generar la curva de regresión que utilizará el servidor de SEAL para ubicar al usuario, dicho servidor cifrará los datos de temperatura del último año en dos ubicaciones distintas y se las enviará al servidor TFHE. Este procesa los datos cifrados y calcula la regresión cuadrática codificada en tres parámetros $a, b, c$ que devolverá cifrados al servidor de SEAL.

$ DIAGRAMA PARA SUBIR DATOS DE SEAL A TFHE$

\subsection{Curva de regresión}

Esta curva $ y = f(x) $ está definida por tres parámetros ($a$, $b$ y $c$) de forma que:

\[ y = ax^2 + bx + c \]

Resultante de resolver el siguiente sistema de ecuaciones:

\begin{gather*}
    \begin{cases}
        \sum_{i=0}^n y_i = a*\sum_{i=0}^n x_i^2 + b*\sum_{i=0}^n x_i + n*c \\
        \sum_{i=0}^n y_i = a*\sum_{i=0}^n x_i^3 + b*\sum_{i=0}^n x_i^2 + c*\sum_{i=0}^n x_i \\
        \sum_{i=0}^n y_i = a*\sum_{i=0}^n x_i^4 + b*\sum_{i=0}^n x_i^3 + c*\sum_{i=0}^n x_i^2
    \end{cases}
\end{gather*}

Realizando las siguientes sustituciones:

\begin{align*}
    i &= \sum_{i=0}^n x_i & j &= \sum_{i=0}^n x_i^2 & k &= \sum_{i=0}^n x_i^3 & l &= \sum_{i=0}^n x_i^4 \\
    u &= \sum_{i=0}^n y_i & v &= \sum_{i=0}^n x_i * y_i & w &= \sum_{i=0}^n x_i^2 * y_i
\end{align*}

Obtendríamos un sistema lineal de ecuaciones solucionable mediante eliminación Gauss-Jordan:

\begin{gather*}
    \begin{cases}
        u = a*j + b*i + n*c \\
        v = a*k + b*j + c*i \\
        w = a*l + b*k + c*j
    \end{cases}
\end{gather*}

Además de la propia implementación con TFHE, se ha desarrollado un código de ejemplo en python mucho más legible \ref{regresion_cuadratica.py}.

TFHE sólo ofrece operadores lógicos, así que tenemos que escribir la operaciones aritméticas necesarias: suma, resta, multiplicación y división. Además tendremos que dar la posibilidad de trabajar con números reales, por lo que tendremos que determinar la codificación más apropiada. Para todo ello se ha desarrollado la librería \texttt{tfhe-math}

\subsection{tfhe-math}

El desarrollo de esta librería ha sido quizás la parte más costosa del trabajo, pero también la que más resultados arroja sobre la implementación de criptografía homomórfica en un entorno real. Como hemos comentado, hemos desarrollado las operaciones aritméticas necesarias para poder realizar la regresión cuadrática teniendo en cuenta que necesitábamos codificar los valores como número reales.

TFHE sólo trabaja con arrays de bits cifrados, y los datos no se pueden evaluar durante la ejecución del programa, así que hemos tenido que meter algunas funciones redundantes para cubrir todos los supuestos: Por ejemplo, en la multiplicación trabajamos asumiendo que los dos factores tienen signo positivo y corregimos el resultado utilizando la puerta lógica \texttt{MUX}. Por otro lado, como hay algunos casos en los que vamos a tener la certeza del signo de los operandos (porque lo hemos gestionado ya antes), y la lógica de tratamiento del signo es muy pesada, hemos creado algunas funciones para trabajar con números sin signo, cuyo nombre hemos precedido de \texttt{u_} (de \textit{unsigned}).

A la hora de trabajar con los números con coma flotante, para proteger los decimales al codificar el número como entero, les asignamos un número determinado de bits. Por defecto, cuando trabajamos con números de 64 bits, les asignamos 10 (y así podemos guardar 3 decimales). Así por ejemplo, si queremos trabajar con el número $ 3.14 $, lo multiplicamos por $ 1024 $ ($ 2^10 $, el equivalente a moverlo 10 bits hacia la izquierda) y trabajamos con $ 3215 $. Lo hacemos de esta forma (en lugar de, por ejemplo, multiplicar por 10) porque la operación de desplazamiento de bits es casi gratuita (en cuanto a tiempo de cómputo), mientras que la multiplicación y la división son muy costosas. Cuantos más bits introduzcamos, obtendremos mayor precisión, pero bajará la eficiencia.

Tenemos que tener precaución principalmente en dos aspectos:

\begin{enumerate}

  \item En el producto y en la división también se multiplican y dividen los desplazamientos. Por ejemplo si trabajamos con dos números ($a$ y $b$) a los que les hemos aplicado el desplazamiento de 10 bits ($ a' = a * 2^{10}, b' = b * 2^{10} $). Hay que restaurar la escala antes de la división:

  \begin{gather}
    a' / b' = ( a * 2^{10} ) / ( b * 2^{10} ) = (a / b) \\
    (a / b) \notequal (a / b) * 2^{10}
  \end{gather}

  Para que al restaurar el número no haya errores quitando las posiciones de los decimales:

  \begin{gather}
    a' / b' \rightarrow (a' * 2^{10})/b' = (a / b) * 2^{10}
  \end{gather}

  Y hay que restaurar la escala tras la multiplicación:

  \begin{gather}
    a' * b' = ( a * 2^{10} ) * ( b * 2^{10} ) = a * b * 2^{20} \\
    a * b * 2^{20} \notequal a * b * 2^{10}
  \end{gather}

  Para, además de evitar errores al restaurar el número, no se produzcan desbordamientos (si $a$ es de 4 bits, y $b$ es de 3, $ a * b $ ocupará 7 bits):

  \begin{gather}
    a' * b' \rightarrow (a' * b') / 2^{10} = (a / b) * 2^{10}
  \end{gather}

  \item La gestión del signo

  Para trabajar con el signo de los números se codifican en complemento a 2 \cite{complemento_a_2}. En la suma y la resta podemos operar libremente, pero a la hora de hacer la división y el producto (nuevamente) hemos tenido que implementar los algoritmos que "no entienden de signo".  Siempre que necesitamos trabajar con algoritmos sin signo, y como no podemos cambiar el flujo de ejecución en función del mismo (porque no podemos verlo), realizamos el siguiente proceso con cada operando:

  \begin{enumerate}
    \item Negamos el operando: Para ello hemos creado la función \texttt{negativo} que devuelve el negativo del número si es positivo, y el positivo si es negativo.
    \item Guardarmos (usando la puerta \texttt{MUX}) el mayor de los dos para asegurarnos de trabajar con el número en positivo
    \item Guardamos en un bit (cifrado, un bit que no vemos pero que \texttt{MUX} será capaz de interpretar) si el número es positivo (guardarmos \texttt{0}) o negativo (guardamos \texttt{1})
    \item Tras operar comparamos con la puerta \texttt{XOR} los bits que indican si los operandos eran positivos o negativos. Nos devolverá \texttt{0} sólo si ambos eran positivos o negativos, indicando que no hay que hacer ninguna corrección. Llamaremos a este bit \texttt{corrector}.
    \item Aplicamos la función \texttt{negativo} sobre el resultado, y esta vez determinamos (usando \texttt{MUX} qué devolver con el parámetro \texttt{corrector}: Si es \texttt{1} devolvemos el resultado negado, si es \texttt{0} el mismo que ha devuelvo el cálculo.
  \end{enumerate}

\end{enumerate}}

A continuación veremos cómo trabajan nuestras principales funciones:

\begin{itemize}
  \item gte
  \item is_negative
  \item negativo
  \item minimum/maximum
  \item shiftl/shiftr
  \item add / sub
  \item mult
  \item div

\end{itemize}

$ OPERACIONES DE FUNCTIONS.h $

He hecho las siguientes operaciones aritméticas:

- Suma

\subsection{Modelo Cliente-Servidor}


\section{Implementación con SEAL}

\subsection{Cálculo de la posición}

EL sistema CKKS ofrece la posibilidad de trabajar con varios datos a la vez codificándolos como vectores

\subsection{Modelo Cliente-Servidor}
