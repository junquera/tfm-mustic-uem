\chapter{Implementaciones}
\label{chap:libs}

\section{Librerías}

Hay varias implementaciones de criptografía homomórfica, y varias soluciones por cada una de las generaciones.

\begin{itemize}
    \item HELib
    \item Microsoft SEAL
    \item PALISADE
    \item HeaAn
    \item LoL
    \item NFLlib

    \item TFHE
    \item FHEW
    \item cuHE
\end{itemize}{}

Para nuestro trabajo utilizaremos las librerías SEAL (como representante de la segunda generación de criptografía homomórfica) y THFE (como representante de la tercera). Para la segunda generación habría sido también una muy buena opción utilizar PALISADE, pero la documentación es mucho menor, y no incluye el esquema CKKS.

\section{SEAL}

SEAL es:

- Fácil de instalar

- No tiene dependencias externas (más allá de '-lpthread')

- Integrable con cmake

- Tiene varias opciones de criptografía homomórfica (BGV, {somewhat|fully}hom.encrypt)

- Dentro de su código fuente se incluyen varios ejemplos que muestran cómo se opera con ella.

- La clave es determinar qué operación se quiere hacer:
    - Codificarla

    - Elegir correctamente los parámetros que permitan que se haga

- Bajo determinados usos, puede ser insegura. Por ejemplo, no se debe permitir el descifrado desde fuera \cite{peng_danger_2019} (no es CCA seguro).


La API para operar con SEAL está codificada en los siguientes elementos:

\begin{itemize}
  \item EncryptionParameters
  \item SEALContext
  \item Claves
  \begin{itemize}
    \item SecretKey: Clave secreta para descifrar los datos
    \item PublicKey: Clave pública para descifrar los datos
    \item RelinKeys: CLaves públicas para realinearizar los datos y reducir el nivel de error acumulado tras operar
    \item GaloisKeys: Claves públicas para trabajar con rotaciones en los vectores cifrados (en nuestro ejemplo no las usamos)
  \end{itemize}
  \item Encryptor, Decryptor: Sistemas para cifrar y descifrar los datos
  \item Evaluator: Es el componente que realiza las operaciones sobre los datos cifrados
  \item Encoders: Encargado de codificar los datos en función del esquema que se desee utilizar
\end{itemize}

A continuación desarrollaremos el funcionamiento de los componentes más complejos.

\subsection{EncryptionParameters}



\subsection{SEALContext}



\subsection{Encoders}

- SEAL ofrece encoders para la información:

    - IntegerEncoder

    Descompone el número en una sucesión de exponenciaciones.

    - BatchEncoder

    Crea matrices

    - CCKSEncoder

    Crea matrices (In CKKS the number of slots is poly\_modulus\_degree / 2 and each slot encodes one real or complex number.) Para operar con reales, se pasan a enteros (multiplicando por $10^x$) perdiendo precisión y aumentando el tamaño.


    En ambos modelos las matrices se pueden rotar haciendo uso de unas claves especiales llamadas Galois Keys (ejemplo 5 de SEAL).

\subsection{Niveles de error}

...

\subsection{Trabajo con vectores}

...

\subsection{Esquema BFV}

Usando BFV el texto tiene un parámetro llamado "noise budget" que indica el nivel de ruido que se ha generado en el texto cifrado (atención: budget es "fichas" que se pueden gastar generando ruido). Este nivel de ruido aumenta a medida que se opera (en realidad, va disminuyendo hasta 0), y cuando llega a 0 indica que, si se sigue operando, no se podrá recuperar el texto.

% Plaintexts in the BFV scheme are polynomials of degree less than the degree of the polynomial modulus, and coefficients integers modulo the plaintext modulus.

Hay tres parámetros principalmente:

- $poly_modulus_degree$

Determina el módulo del polinomio usado en LWE. Cuanto más largo, más operaciones se pueden hacer (puede crecer más el resultado), pero es más lento.
% REPASAR ESTO ^

- $coeff_modulus$

Número primos concatenados (vector de números primos) que determinan el módulo del texto cifrado. A mayor módulo, más $noise_budget$. Viene acotado superiormente por el $poly_modulus_degree$.

- $plain_modulus$

Modulo del texto plano. CUanto más pequeño, más lento crece el $error_budget$: the noise budget consumption in a homomorphic multiplication is of the form $log2(plain_modulus) + (other terms)$

The noise budget in a freshly encrypted ciphertext is $~ log2(coeff_modulus/plain_modulus)$  (bits)

% Hay que convertir a Strings todos los números con los que se quiere operar

\if false
Realinearization:

`Relinearization' is an operation that reduces the size of a ciphertext after
    multiplication back to the initial size, 2. Thus, relinearizing one or both
    input ciphertexts before the next multiplication can have a huge positive
    impact on both noise growth and performance, even though relinearization has
    a significant computational cost itself. It is only possible to relinearize
    size 3 ciphertexts down to size 2, so often the user would want to relinearize
    after each multiplication to keep the ciphertext sizes at 2.

    Relinearization requires special `relinearization keys', which can be thought
    of as a kind of public key. Relinearization keys can easily be created with
    the KeyGenerator.

    % TODO Volver a leer 1_bfv_basic para entender size 3, size 2...
    % El tamaño tras operar M con N es M+N-1
\fi

\if false

Levels: Permite ir reduciendo los coeff\_modulus para reducir el tamaño del texto cifrado cuando ya no se van a hacer más operaciones, y que las operaciones se hagan rápido.

\fi

\subsection{Esquema CKKS}

% TODO BFV vs CKKS

En este esquema podremos trabajar con número decimales, pero hay que estar ajustando constantemente los parámetros para que no se desborde el tamaño y se mantenga la integridad de lo calculado.

Se elige una escala inicial menor que los coeff\_modulus para que permita operar con los valores correctamente (por ejemplo, si el tamaño del coeff\_mod es 60 bits se elige una escala de 40 bits para tener 20 de margen).

Lo suyo es elegir los coeff\_modulus para que el primero y el último sean más grandes (el primero para tener más precisión al quitar la escala y volver a poner en decimal, el último para poder hacer una escala cómodamente), y el resto normales (para que no sean muy pesadas las operaciones. Cuando se hace una multiplicación el tamaño del texto inicial S se convierte en $S^2$, por lo que hay que reescalarlo. Si se reescala al coeff\_modulus (de tamaño M) correspondiente en la cadena, se tiene un texto $S^2/M$ que, si se han elegido bien los parámetros, será muy parecido a S.

Además la operación de suma requiere que los sumandos estén en la misma escala, lo que es un problema tras haber operado previamente con ellos (linea 253 del ejemplo 4 de SEAL)...

Especialmente destinado a trabajar con vectores (como en el modo BatchEncoder).

\section{TFHE}

% TODO Completar

Instalación: https://tfhe.github.io/tfhe/installation.html

EN su presentación (http://lab.algonics.net/slides/index-ccs.html) dicen: "If Spiderman can swing on his rope long enough to launch a new rope he can fly!"

En TFHE se trabaja directamente con puertas lógicas. No hay ningún parámetro adicional que seleccionar, tiene una API muy limitada, pero para hacer cualquier cálculo hay que implementarlo desde el nivel más bajo.

Cuando se cifra un texto se genera un array de bits del texto cifrado.

Los elementos son mucho menos complejos que en SEAL, y está codificado en unos pocos grupos de elementos:

\begin{itemize}
  \item Parámetros de cifrado (\texttt{TFheGateBootstrappingParameterSet})
  \item Claves: Privada ( (\texttt{TFheGateBootstrappingSecretKeySet})) y pública (\texttt{TFheGateBootstrappingCloudKeySet})
  \item Operaciones de cifrado y descifrado
  \item Operaciones lógicas sobre texto cifrado (\texttt{LweSample})
\end{itemize}

Además, TFHE ofrece funciones para limpiar la memoria, dejando en manos del desarrollador la posibilidad de evitar fugas de información una vez no se va a utilizar un elemento.

\subsection{API}

A continuación haremos un repaso de las principales operaciones incluidas en la librería TFHE.

\begin{itemize}

  \item bootsCONSTANT

  Carga una constante en \verb|value| en la variable cifrada \verb|result|.

  \begin{lstlisting}[language=c++]
    void bootsCONSTANT(LweSample* result, int value,
                      const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  \item bootsNOT

  Niega el valor de la variable \verb|ca| y lo almacena en \verb|result|.

  \begin{lstlisting}[language=c++]
    void bootsNOT(LweSample* result, const LweSample* ca,
                  const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  % TODO Alinear y verbatim
  % TODO Etiquetar los códigos
  \item bootsCOPY

  Copia el valor de la variable \verb|ca| y lo almacena en \verb|result|. Cuando se utilizan tanto esta función como las funciones \verb|bootsCONSTANT|  y \verb|bootsNOT| se suele trabajar bit a bit iterando sobre los dos arrays. Si no se hace así, a veces pueden tener comportamientos erráticos.

  \begin{lstlisting}[language=c++]
    bootsCOPY(LweSample* result, const LweSample* ca,
              const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  \item bootsMUX

  Es una implementación del operador ternario (\verb|a ? b : c|) esencial para poder introducir cómputos con divergencias en su flujo de ejecución aunque (como hemos comentado anteriormente) no podamos modificarlo. Asigna a \verb|result| el valor de \verb|b| si se cumple \verb|a|, si no, le asigna el valor de \verb|c|.

  \begin{lstlisting}[language=c++]
    bootsMUX(LweSample* result, const LweSample* a,
            const LweSample* b, const LweSample* c,
            const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  Esta función es especialmente interesante, y es la que le da todo el valor a la librería para hacer implementaciones complejas. Por ejemplo, una función con el siguiente código:

  \begin{lstlisting}[language=c++]
    while (result < 100)
      result = result * 2;
  \end{lstlisting}

  No podría ser implementada sin evaluar el valor de result. Sin embargo, con el operador \verb|MUX| podemos hacer lo siguiente (es pseudocódigo):

  \begin{lstlisting}[language=c++]
    /*
     Hasta que el número más pequeño que podamos escribir con los
     bits que hemos asignado a los decimales no sea mayor que 100
    */
    for (int i = 0.001; i < 100; i = i*2) {
      gte(es_mayor, result, 100); // es_mayor =  result >= 100
      bootsMUX(factor, es_mayor, 2, 1); // factor = es_mayor ? 2 : 1
      multiplica(result, result, factor); // result = result * factor
    }
  \end{lstlisting}

  \item Puertas lógicas

  También implementa las siguientes puertas lógicas booleanas. La utilizaremos como base para hacer el resto de operaciones, como por ejemplo la suma (la función de suma es igual que un circuito sumador).

  \begin{itemize}
    \item NAND

    \item OR

    \item AND

    \item XOR

    \item XNOR

    \item NOR

    \item ANDNY, ANDYN

    \item ORNY, ORYN

  \end{itemize}

\end{itemize}

\subsection{Evolución de TFHE}

En su desarrollo se plantea la implementación de un modo conocido como Chimera ...
