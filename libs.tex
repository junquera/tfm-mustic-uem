\chapter{Implementaciones}
\label{chap:libs}

\section{Librerías}

Hay varias implementaciones de criptografía homomórfica, y varias soluciones por cada una de las generaciones. Aunque la mayoría de las implementaciones están escritas para \verb|C/C++/C#| Recientemente han ido apareciendo algunas nuevas que buscan, principalmente, adaptar los esquemas de cifrado a otros lenguajes. Aunque esto es una nueva noticia, nosotros nos centraremos en las "clásicas" evaluadas por el consorcio de standarización:

\begin{itemize}
    \item Segunda generación
    \begin{itemize}
        \item HELib
        \item Microsoft SEAL
        \item PALISADE
        \item HeaAn
        \item LoL
        \item NFLlib
    \end{itemize}
    \item Tercera generación
    \begin{itemize}
        \item TFHE
        \item FHEW
        \item cuHE
    \end{itemize}
\end{itemize}

Para nuestro trabajo utilizaremos las librerías Microsoft SEAL (como representante de la segunda generación de criptografía homomórfica) y THFE (como representante de la tercera). Para la segunda generación habría sido también una muy buena opción utilizar PALISADE, pero la documentación es mucho menor, y no incluye el esquema CKKS (necesario para trabajar con números reales).

\section{Microsoft SEAL}
\label{tag:msfseal}

Esta librería de código abierto desarrollada por Microsoft (\textit{SEAL} de ahora en adelante) busca ofrecer una opción asequible para los desarrolladores de implementar soluciones con criptografía homomórfica.

Es muy fácil de instalar, no tiene dependencias externas, y está diseñada para ser construida en cualquier entorno con \verb|cmake|.

Cuenta con dos esquemas de cifrado de segunda generación (BGV y CKKS) y dentro de su código fuente se incluyen varios ejemplos que muestran cómo se opera con ella. En estos ejemplos, ordenados para conocer las distintas herramientas, muestran todo lo necesario para empezar a trabajar.

A la hora de implementar una idea en SEAL, hay dos aspectos clave a tener en cuenta:

\begin{enumerate}
  \item Elegir el esquema de cifrado que nos permita codificar todo correctamente
  \item Estudiar si la operación realmente es realizable con estos esquemas (recordemos que SHE tiene una cota de cómputo)
\end{enumerate}

Además, hay que ser consciente de que bajo determinados usos, puede ser insegura. Por ejemplo, no se debe permitir el descifrado desde un entorno no controlado (no es CCA seguro (\cite{peng_danger_2019})).

\subsection{API}

La API para operar con SEAL está codificada en los siguientes elementos:

\begin{itemize}
  \item EncryptionParameters
  \item SEALContext
  \item Claves
  \begin{itemize}
    \item SecretKey
    Clave secreta para descifrar los datos
    \item PublicKey
    Clave pública para descifrar los datos
    \item RelinKeys
    Claves públicas para realinearizar los datos y reducir el nivel de error acumulado tras operar
    \item GaloisKeys
    Claves públicas para trabajar con rotaciones en los vectores cifrados (en nuestro ejemplo no las usamos)
  \end{itemize}
  \item Encryptor, Decryptor
  Sistemas para cifrar y descifrar los datos
  \item Evaluator
  Es el componente que realiza las operaciones sobre los datos cifrados
  \item Encoders
  Encargado de codificar los datos en función del esquema que se desee utilizar
\end{itemize}

A continuación explicaremos más detalladamente el funcionamiento de los componentes más complejos.

\subsection{EncryptionParameters}

Los parámetros criptográficos dependerán del esquema con el que se quiere trabajar.

\begin{itemize}

  \item BFV

  BFV es el esquema "básico" de SEAL. Permite trabajar con números enteros, y operar con ellos hasta que se alcanza el límite máximo de error. En BFV, este límite se podría conceptualizar como un cubo de fichas que se gastan cada vez que se opera. Hay algunas operaciones que son casi gratuitas (la suma y la resta), y la multiplicación es muy costosa. Una vez se vacía este cubo (codificado en el parámetro \verb|noise_budget|), nuestro cifrado quedará corrupto y no se puede recuperar el texto.

  % Plaintexts in the BFV scheme are polynomials of degree less than the degree of the polynomial modulus, and coefficients integers modulo the plaintext modulus.

  Además de \verb|noise_budget|, hay tres parámetros configurables que guardan una estrecha relación:

  - \verb|poly_modulus_degree|

  Determina el módulo del polinomio usado para realizar las operaciones criptográficas (recordemos que implementa LWE sobre un anillo de polinomios, ver \ref{tag:bfv}). Se expresará como una potencia de 2 que cuanto más grande sea, más operaciones permitirá hacer, pero serán más lentas.

  - \verb|coeff_modulus|

  Es un vector de números primos que determina el módulo del texto cifrado. A mayor módulo, mayor será el \verb|noise_budget|. Cuando decíamos que a mayor \verb|poly_modulus_degree|, podíamos hacer más operaciones, era porque el número de bits de \verb|coeff_modulus| está acotado por el de \verb|poly_modulus_degree| de la siguiente forma:

  \begin{tabular}{ | c | c | }
    \verb|poly_modulus_degree|  & Número de bits de \verb|coeff_modulus| \\
    \hline
    1024  & 27  \\
    2048  & 54  \\
    4096  & 109 \\
    8192  & 218 \\
    16384 & 438 \\
    32768 & 881
  \end{tabular}

  - \verb|plain_modulus|

  Modulo del texto plano. El consumo de \verb|noise_budget| se produce de forma logarítmica en base al tamaño de \verb|plain_modulus|, por lo que cuanto más pequeño es, más operaciones podremos realizar.

  \item CKKS

  En este esquema podremos trabajar con número decimales, pero hay que estar ajustando constantemente los parámetros para que no se desborde el tamaño y se mantenga la integridad de lo calculado.

  Comparte con BGV el \verb|poly_modulus_degree| y \verb|coeff_modulus|, pero desaparece el \verb|plain_modulus|, y los valores de \verb|coeff_modulus| tienen otras implicaciones.

  Reescalado: cuando se reescala se hace ...

  Se elige una escala inicial menor que los \verb|coeff_modulus| para que permita operar con los valores correctamente (por ejemplo, si el tamaño del \verb|coeff_mod| es 60 bits se elige una escala de 40 bits para tener 20 de margen).

  Lo suyo es elegir los coeff\_modulus para que el primero y el último sean más grandes (el primero para tener más precisión al quitar la escala y volver a poner en decimal, el último para poder hacer una escala cómodamente), y el resto normales (para que no sean muy pesadas las operaciones. Cuando se hace una multiplicación el tamaño del texto inicial S se convierte en $S^2$, por lo que hay que reescalarlo. Si se reescala al coeff\_modulus (de tamaño M) correspondiente en la cadena, se tiene un texto $S^2/M$ que, si se han elegido bien los parámetros, será muy parecido a S.

  Además la operación de suma requiere que los sumandos estén en la misma escala, lo que es un problema tras haber operado previamente con ellos (linea 253 del ejemplo 4 de SEAL)...

  Especialmente destinado a trabajar con vectores (como en el modo BatchEncoder).

\end{itemize}

\subsection{SEALContext}

% When a SEALContext is created from a given EncryptionParameters instance,
% Microsoft SEAL automatically creates a so-called `modulus switching chain',
% which is a chain of other encryption parameters derived from the original set.

% Each set of parameters in the chain involves unique pre-computations performed
% when the SEALContext is created, and stored in a SEALContext::ContextData
% object. The chain is basically a linked list of SEALContext::ContextData
% objects, and can easily be accessed through the SEALContext at any time. Each
% node can be identified by the parms_id of its specific encryption parameters
% (poly_modulus_degree remains the same but coeff_modulus varies).

\subsection{Evaluator}

Operaciones de Evaluator:

...

\subsection{Encoders}

SEAL ofrece tres sistemas para codificar los datos con los que se va a trabajar:

    - IntegerEncoder (BFV)

    Descompone el número en una sucesión de exponenciaciones.

    - BatchEncoder (BFV)

    Crea matrices para BFV.

    The total number of batching `slots' equals the poly_modulus_degree, N, and
    these slots are organized into 2-by-(N/2) matrices that can be encrypted and
    computed on. Each slot contains an integer modulo plain_modulus.

    Matriz con dos filas.

    Se introduce un vector, y si se introduce un solo valor, llena todo con el valor.

    - CCKSEncoder

    Crea matrices para CKKS.


     (In CKKS the number of slots is poly\_modulus\_degree / 2 and each slot encodes one real or complex number.) Para operar con \textbn{reales}, se pasan a enteros (multiplicando por $10^x$) perdiendo precisión y aumentando el tamaño.

\subsection{Niveles de error y realinearización}

A medida que se opera, el error aumenta. La suma es casi gratuita, pero con el producto de dos elementos de tamaño M y N, teniendo el resultado tamaño M+N-1, el error aumenta considerablemente. Interpretaremos este tamaño como el grado polinómico del elemento.

La realinearización es una operación que permite reducir el tamaño tras una multiplicación. Tiene un coste computacional alto en comparación con el resto de operaciones, pero permite que la operaciones posteriores sean más eficientes, y que el elemento no crezca hasta "romperse".

% Relinearization requires special `relinearization keys', which can be thought
% of as a kind of public key. Relinearization keys can easily be created with
% the KeyGenerator.

Levels: Permite ir reduciendo los coeff\_modulus para reducir el tamaño del texto cifrado cuando ya no se van a hacer más operaciones, y que las operaciones se hagan rápido.

Se corresponden con los eslabones de la cadena del SEALContext.


%           special prime +---------+
%                                   |
%                                   v
% coeff_modulus: { 50, 30, 30, 50, 50 }  +---+  Level 4 (all keys; `key level')
%                                            |
%                                            |
%     coeff_modulus: { 50, 30, 30, 50 }  +---+  Level 3 (highest `data level')
%                                            |
%                                            |
%         coeff_modulus: { 50, 30, 30 }  +---+  Level 2
%                                            |
%                                            |
%             coeff_modulus: { 50, 30 }  +---+  Level 1
%                                            |
%                                            |
%                 coeff_modulus: { 50 }  +---+  Level 0 (lowest level)


Se puede descender, pero nunca ascender. Cuanto más abajo, más rápidos son los cálculos, pero menos cálculos se pueden hacer. En ocasiones, debido al tamaño del texto plano, descender no tendrá consecuencias en cuanto al nivel de error, por lo que se podrá hacer para tener mayor eficiencia.

Mientras que en BGV esto no tiene mucha importancia (más allá de la eificiencia) en CKKS la cosa cambia. Cuando se reescala en CKKS, se está eliminando al mismo tiempo parte de esta cadena

More precisely, suppose that the scale in a CKKS ciphertext is S, and the
    last prime in the current coeff_modulus (for the ciphertext) is P. Rescaling
    to the next level changes the scale to S/P, and removes the prime P from the
    coeff_modulus, as usual in modulus switching. The number of primes limits
    how many rescalings can be done, and thus limits the multiplicative depth of
    the computation.


Tras cada multiplicación, el valor con tamaño S multiplicado y el coeff_modulus con tamaño P: they have scale S^2 after multiplication, and S^2/P_i after rescaling.

POr ello, la idea es tener el mayor número posible de valores (para poder hacer muchos productos) dejando el último más grande (realmente, el primer valor de la cadena) para no perder precisión. Si el penúltimo es por ejemplo 40, y el último 60 (como en los ejemplos) al hacer la última multiplicación el tamaño se duplicará hasta 80, por lo que al pasar a 60, solo perdemos 20 bits (en lugar de 40) si tiene el mismo tamaño.

\subsection{Trabajo con vectores}

Tanto BatchEncoder como CKKSEncoder, interpretan todos los datos como vectores.

\begin{gather}
  \begin{pmatrix}
    c_1 \\
    c_2 \\
    \vdots{} \\
    c_n
  \end{pmatrix}
  =
  \begin{pmatrix}
    a & a & \hdots{} &  a
  \end{pmatrix}
  *
  \begin{pmatrix}
    \Box \\
    \Box \\
    \vdots{} \\
    \Box
  \end{pmatrix}
\end{gather}

Una de las cosas más interesantes de esta forma de codificar los datos, es que se pueden rotar las columnas y las filas. La rotación es cíclica, cuando se rota una posición a la izquierda, el primer valor pasa a la última posición.

%
%     [  0,  1,  2,  3,  0, ...,  0,  0,  0,  0,  0 ]
%     [  4,  5,  6,  7,  0, ...,  0,  0,  0,  0,  0 ]
%
% Line  60 --> Encode and encrypt.
%     + Noise budget in fresh encryption: 134 bits
%
% Line  78 --> Rotate rows 3 steps left.
%     + Noise budget after rotation: 134 bits
%     + Decrypt and decode ...... Correct.
%
%     [  3,  0,  0,  0,  0, ...,  0,  0,  0,  1,  2 ]
%
%     [  7,  0,  0,  0,  0, ...,  0,  0,  4,  5,  6 ]
%
% Line  92 --> Rotate columns.
%     + Noise budget after rotation: 134 bits
%     + Decrypt and decode ...... Correct.
%
%     [  7,  0,  0,  0,  0, ...,  0,  0,  4,  5,  6 ]
%     [  3,  0,  0,  0,  0, ...,  0,  0,  0,  1,  2 ]


\section{TFHE}

En TFHE se trabaja directamente con puertas lógicas. No hay ningún parámetro adicional que seleccionar (mas allá de los relacionados con generar una clave aleatoria), tiene una API simple pero muy potente, pero para hacer cualquier cálculo hay que implementarlo desde el nivel más bajo. Cuando se cifra un dato se genera un array de bits correspondiente al dato cifrado. Será este array (codificado en la clase \verb|LweSample|) sobre el que aplicaremos los algoritmos y procedimientos que diseñaremos, como si trabajásemos con el texto plano.

Los elementos que forman TFHE son mucho menos complejos que los de SEAL, con un único sistema de cifrado (http://lab.algonics.net/slides_ac16/index-asiacrypt.html).

CONTAR: Sólo definir el parámetro $\lambda$ (ver http://lab.algonics.net/slides_ac16/index-asiacrypt.html#/7)

Están codificados en sólo unos pocos grupos:

\begin{itemize}
  \item Parámetros de cifrado (\texttt{TFheGateBootstrappingParameterSet})
  \item Claves: Privada ( (\texttt{TFheGateBootstrappingSecretKeySet})) y pública (\texttt{TFheGateBootstrappingCloudKeySet})
  \item Operaciones de cifrado y descifrado
  \item Operaciones lógicas sobre texto cifrado (\texttt{LweSample})
\end{itemize}

Además, TFHE ofrece funciones para limpiar la memoria, dejando en manos del desarrollador la posibilidad de evitar fugas de información una vez no se va a utilizar un elemento.

\subsection{API}

A continuación haremos un repaso de las principales operaciones sobre el texto cifrado incluidas en la librería TFHE.

\begin{itemize}

  \item bootsCONSTANT

  Carga una constante en \verb|value| en la variable cifrada \verb|result|.

  \begin{lstlisting}[language=c++]
    void bootsCONSTANT(LweSample* result, int value,
                      const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  \item bootsNOT

  Niega el valor de la variable \verb|ca| y lo almacena en \verb|result|.

  \begin{lstlisting}[language=c++]
    void bootsNOT(LweSample* result, const LweSample* ca,
                  const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  % TODO Alinear y verbatim
  % TODO Etiquetar los códigos
  \item bootsCOPY

  Copia el valor de la variable \verb|ca| y lo almacena en \verb|result|. Cuando se utilizan tanto esta función como las funciones \verb|bootsCONSTANT|  y \verb|bootsNOT| se suele trabajar bit a bit iterando sobre los dos arrays. Si no se hace así, a veces pueden tener comportamientos erráticos.

  \begin{lstlisting}[language=c++]
    bootsCOPY(LweSample* result, const LweSample* ca,
              const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  \item bootsMUX

  Es una implementación del operador ternario (\verb|a ? b : c|) esencial para poder introducir cómputos con divergencias en su flujo de ejecución aunque (como hemos comentado anteriormente) no podamos modificarlo. Asigna a \verb|result| el valor de \verb|b| si se cumple \verb|a|, si no, le asigna el valor de \verb|c|.

  \begin{lstlisting}[language=c++]
    bootsMUX(LweSample* result, const LweSample* a,
            const LweSample* b, const LweSample* c,
            const TFheGateBootstrappingCloudKeySet* bk);
  \end{lstlisting}

  Esta función es especialmente interesante, y es la que le da todo el valor a la librería para hacer implementaciones complejas. Por ejemplo, una función con el siguiente código:

  \begin{lstlisting}[language=c++]
    while (result < 100)
      result = result * 2;
  \end{lstlisting}

  No podría ser implementada sin evaluar el valor de result. Sin embargo, con el operador \verb|MUX| podemos hacer lo siguiente (es pseudocódigo):

  \begin{lstlisting}[language=c++]
    /*
     Hasta que el menor valor que podamos
     escribir con los bits que hemos asignado a
     los decimales (10 bits) no sea mayor que 100
    */
    for (int i = 0.001; i < 100; i = i*2) {
      // es_mayor =  result >= 100
      gte(es_mayor, result, 100);
      // factor = es_mayor ? 2 : 1
      bootsMUX(factor, es_mayor, 2, 1);
      // result = result * factor
      multiplica(result, result, factor);
    }
  \end{lstlisting}

  \item Puertas lógicas

  También implementa las siguientes puertas lógicas booleanas. La utilizaremos como base para hacer el resto de operaciones, como por ejemplo la suma (la función de suma es igual que un circuito sumador).

  \begin{itemize}
    \item NAND

    \item OR

    \item AND

    \item XOR

    \item XNOR

    \item NOR

    \item ANDNY, ANDYN

    \item ORNY, ORYN

  \end{itemize}

\end{itemize}

\subsection{Evolución de TFHE}

En su desarrollo se plantea la implementación de un modo conocido como Chimera (\cite{boura_chimera:_2018}) en el que se puedan mover los datos entre el esquema de TFHE y esquemas más eficientes como BFV, CKKS; y viceversa, sin tener que descifrarlos. Por ejemplo, esto puede ser útil para trabajar con muchas puertas lógicas y hacer alguna operación aritmética rápida entre medias.
