\chapter{Estudio teórico}
\label{chap:teoria}

Para la computación de criptografía homomórfica necesitaremos comprender las bases teóricas matemáticas y los distintos niveles de homomorfismo, además de las herramientas de notación y computación definidas por el estándar...

\section{Tipos}

Las generaciones publicadas por el estándar guardan una estrecha relación con las capacidades que tienen los esquemas para trabajar con los datos cifrados. Estas capacidades que van desde la posibilidad de aplicar algún homomorfismo a poder trabajar libremente con el texto cifrado están categorizadas en tres niveles. Para comenzar, veremos cuales son estos tres tipos:

\begin{itemize}
  \item Partially Homomorphic Encryption

  Existe algún homomorfismo dentro del esquema de cifrado, pero este no es explotable para realizar cómputos arbitrarios con la información. Por ejemplo, el producto en RSA (ver \ref{form:rsa_product})

  \item Somewhat Homomorphic Encryption (SHE)

  Se pueden realizar operaciones arbitrarias, pero el sistema hace que a medida que se procesa la información aumenta el nivel de error del resultado (como veremos, los esquemas de cifrado son semi-probabilísticos), hasta destruir la información. Hay técnicas para aumentar este umbral de error, pero sigue teniendo límites.

  \item Fully Homormorphic Encryption (FHE)

  Los sistemas FHE son los más codiciados dentro del campo, porque permiten realizar cualquier cómputo con la información cifrada sin que aumente el nivel de error y se vuelva irrecuperable. Es cierto que actualmente estos esquemas actualmente son menos eficientes que los anteriores, pero como dicen en TFHE (\cite{noauthor_tfhe:_nodate}): "Si Spiderman puede balancearse sobre su cuerda el tiempo suficiente para lanzar una nueva cuerda, ¡puede volar!"

\end{itemize}


\section{Primitivas matemáticas}

La seguridad de los sistemas criptográficos se basa en problemas matemáticos que, si bien pueden ser resolubles, dicha resolución no es computacionalmente viable en un tiempo razonable: factorización de enteros, logaritmo discreto, ordenación de conjuntos...

La base de los principales sistemas de criptografía homomórfica modernos son problemas relacionados con unas estructuras algebraicas conocidas como retículos.

\subsection{Lattice-based encryption}

Un retículo o red (también conocidos como lattice en inglés) es un conjuntos de elementos similar a un espacio vectorial discreto generado por la combinación de una base vectorial concreta.

Por ejemplo, a los vectores $u = (2, 0)$ y $v = (-1, 3)$ serían la base de la red bidimensional generada por todas sus combinaciones $n*u + m*v$ (ver \ref{fig:lattice1}).

\begin{figure}[h]
  \caption{Espacio vectorial generado por u y v}
  \label{fig:lattice1}
  \includegraphics[]{lattice1}
\end{figure}

Es decir, el conjunto de puntos del gráfico \ref{fig:lattice1} sería un retículo, cuya base está formada por los vectores $u$ y $v$.

En función de lo cerca o lejos que estén los vectores que forman la base del origen se dirá que estas bases son largas o cortas\cite{wickr_what_2018}. Por ejemplo, el espacio anterior podría formarse con el mismo vector $v$, y con otro vector $w = (1, 0)$ más corto que $u$.

En la búsqueda de soluciones criptográficas resistentes a la computación cuántica se han encontrado útiles los siguientes problemas de retículos:

\begin{itemize}
  \item Short Vector Problem (SVP)

  Consiste en dada una base larga, buscar un vector corto lo más cercano al origen, sin ser el origen mismo (ver \ref{fig:svp}).

  \begin{figure}[h]
    \caption{Short vector problem \cite{noauthor_lattice_2019}}
    \label{fig:svp}
    \includegraphics[]{svp}
  \end{figure}

  \item Short Basis Problem (SBP)

  Dada una base larga buscar una base corta del mismo espacio.

  \item Closest Vector Problem (CVP)

  Dada una base larga y un punto $P$ de la red, buscar el vector de la red formada por la base más cercano a $P$ (ver \ref{fig:cvp}).

  \begin{figure}[h]
    \caption{Closest vector problem \cite{noauthor_lattice_2019}}
    \label{fig:cvp}
    \includegraphics[]{cvp}
  \end{figure}


\end{itemize}

Aunque estos problemas puedan parecer triviales a simple vista, su complejidad computacional aumenta exponencialmente con el aumento del número de dimensiones hasta hacerlo computacionalmente irresoluble.

Llamaremos Lattice-based encryption (para ajustarnos a la bibliografía, que está en su práctica totalidad escrita en inglés) a la aplicación de este conjunto de problemas a la criptografía.

En cuanto a nuestro caso, el problema del aprendizaje con errores aplicado a retículos será el núcleo de la criptografía homomórfica.

\subsection{Learn With Errors (LWE)}

El problema del aprendizaje con errores plantea la dificultad de determinar los componentes de una función en base a sus resultados cuando estos contienen errores\cite{apon_intro_nodate}.

Dada una base modular $q$, n vectores $a_i \leftarrow \mathbbb{Z}^m_q$, un vector $s \leftarrow \mathbbb{Z}^n_q$ y $n$ vectores $ e_i \leftarrow \chi{}^m $ tomados de una distribución de error (distribución de Gauss\cite{noauthor_generalized_2019}) \chi{} \subset{} \mathbbb{Z}:

\begin{gather}
    \label{form:gen_lwe}
    b_i = (a_i \times s + e_i) \Mod{q}
\end{gather}

Conociendo $m$ pares $(a_i, b_i)$ no se puede determinar el valor $s$, y no se pueden diferenciar dichos pares de una distribución aleatoria\cite{t._zijlstra_learning_nodate}.

\subsubsection{Uso en criptografía}

En su estudio, Regev\cite{regev_learning_2010} formula un sistema de clave pública utilizando este problema:

\begin{enumerate}
  \item Generación de clave Pública

  Se emite como clave pública una colección de valores $(ai, bi)$ generada como hemos visto en \ref{form:gen_lwe}. El conjunto de vectores $a_i$ se interpretará en algunas implementaciones como una matriz $A \leftarrow \mathbbb{Z}_q^{m \times n}$.

    \begin{figure}[h]
      \caption{LWE \cite{halevi_homomorphic_2017}}
      \label{fig:lwe}
      \includegraphics[width=\textwidth]{lwe}
    \end{figure}

  \item Cifrado

  Para cada bit $x$ a cifrar se elige una de las parejas y se realiza la siguiente operación:

    \begin{gather*}
        \label{form:cifrado_lwe}
        (c1, c2) = (\sum_{j=1}^{m} a_i_j, \sum_{j=1}^{m} b_i_j + x * (q/2))
    \end{gather*}

  \item Descifrado

  El resultado realmente no es determinista, es decir, no devuelve realmente el valor cifrado. Para determinar el valor calcularíamos:

    \begin{gather*}
        \label{form:descifrado_lwe}
        x \approx c_2 - (c_1*s) \\
        b + x*(q/2) - a*s \\
        a*s + e + x*(q/2) - a*s \\
        e + x*(q/2) \approx x * (q/2)
    \end{gather*}

  Si se ha introducido $s$ correctamente, y siendo $e$ despreciable en comparación con $ q/2 $, obtendríamos como resultado $ x * (q/2) $, por lo que sabremos que $ x = 1$ si el resultado es cercano a $ q/2 $ y  $ x = 0 $ si el resultado es cercano a $ 0 $.

\end{enumerate}

En el apéndice \ref{appendix:test_lwe.py} puede verse un ejemplo de implementación del algoritmo, y el resultado de su ejecución.

\section{Generaciones}

En base a los encuentros del estándar ...

La primera generación ...

En la segunda se asientan los modelos SHE que permiten el cálculo de variables acotadas. Estos cálculos ya son fully homomorphic (suma y multi), pero a medida que se opera con las variables va aumentando un nivel de error que hace que sea imposible seguir calculando y obtener resultados válidos. A esta generación pertenecen los esquemas BGV, BFV y CKKS. Estos dos últimos están implementados en la librería SEAL.

La tercera y última generación ya es considerada FHE, pues permite, gracias al esquema GSW, realizar infinitas operaciones sin perder precisión. Para el desarrollo de este tercer estándar usaremos TFHE.

\subsection{Pre-HE}

Dentro de la categoría de esquemas previos a la criptografía homomórfica se encuentran aquellos que, o bien tienen propiedades homomórficas de forma casual, o bien no cumplen las condiciones necesarias para que se puedan utilizar en ningún sistema. Hablaremos de RSA por lo intuitivo que es para comprender la criptografía homomórfica, y del sistema desarrollado por Boneh, Goh y Nissim por ser uno de los primeros orientados correctamente a la computación con criptografía homomórfica.

\begin{itemize}

    \item RSA

    Las propiedades matemáticas de RSA lo convierten en un esquema con homomorfismo en el producto. Para cifrar y descifrar, en RSA se exponencia el elemento al que se le desea aplicar la operación. Siendo $e$ la clave de cifrado y $d$ la clave de descifrado, la aplicación de RSA (puro) sobre el mensaje $m$ sería tal que:

    \begin{gather*}
        c = m^e \Mod{n} \\
        m = c^d \Mod{n}
    \end{gather*}

    Esto hace que, si multiplicamos dos mensajes cifrados:

    \begin{gather*}
        c_1 = m_1^e \Mod{n}, c_2 = m_2^e \Mod{n} \\
        c_1 * c_2 = m_1^e * m_2^e \Mod{n} = (m_1*m_2)^e \Mod{n}
    \end{gather*}

    Podamos obtener el producto de los dos elementos al descifrar:

    \begin{gather*}
        \label{form:rsa_product}
        (m_1^e * m_2^e)^d \Mod{n} \\
        ((m_1*m_2)^e)^d \Mod{n} \\
        m_1 * m_2
    \end{gather*}

    \item Criptosistema de Boneh–Goh–Nissim (\cite{hutchison_evaluating_2005})

    Permite evaluar circuitos lógicos en forma normal disyuntiva (reducido a puertas lógicas \verb|or|, \verb|and| y \verb|not|) sobre texto cifrado. Se traduce en la capacidad de evaluar polinomios de segundo grado. Aunque en comparación con los esquemas actuales este parezca "de juguete", es un gran aporte a la hora de impulsar la investigación en criptografía homomórfica.

\end{itemize}

\subsection{Primera generación}

\begin{itemize}

    \item Bootstrapping: Fully homomorphic encryption using ideal lattices

    La técnica de \textit{bootstrapping} de Gentry (\cite{gentry_fully_2009}) revoluciona la criptografía homomórfica. Estipula que para crear un esquema de cifrado que permita la evaluación arbitraria de circuitos lógicos símplemente hace falta un esquema de cifrado que pueda realizar la operación de descifrado sin realmente descifrar el texto. Esto se consigue mediante algo parecido a mezclar el texto cifrado (en el que se produce ruido tras hacer una operación) con una versión cifrada de la clave secreta para que se elimine el ruido.

    Por ejemplo, cuando se evalúa usando la técnica de \textit{bootstrapping} la operación $ c_a + c_b$ con $c_a, c_b$ textos cifrados, $e(x)$ función de cifrado y  $d(x)$ función de descifrado, el resultado es $e( e_{-1}(c_a + c_b) )$. En la operación de descifrado intermedia se elimina el ruido, y el propio esquema hace que no permita al evaluador de la operación revelar la clave secreta. (\cite{noauthor_homomorphic_nodate-3}).

    El principal problema de la operación de \textit{bootstrapping} es que consume mucho tiempo. En la segunda generación el principal esfuerzo es crear esquemas más rápidos.

\end{itemize}

\subsection{Segunda generación}

\begin{itemize}

    \item BGV

    We present a radically new approach to fully homomorphic encryption (FHE) that dramatically improves performance and bases security on weaker assumptions. A central conceptual contribution in our work is a new way of constructing leveled fully homomorphic encryption schemes (capable of evaluating arbitrary polynomial-size circuits), {\em without Gentry's bootstrapping procedure}.

    Specifically, we offer a choice of FHE schemes based on the learning with error (LWE) or ring-LWE (RLWE) problems that have 2\secparam

    security against known attacks. For RLWE, we have:

    1. A leveled FHE scheme that can evaluate L
    -level arithmetic circuits with O~(\secparam⋅L3) per-gate computation -- i.e., computation {\em quasi-linear} in the security parameter. Security is based on RLWE for an approximation factor exponential in L

    . This construction does not use the bootstrapping procedure.

    2. A leveled FHE scheme that uses bootstrapping {\em as an optimization}, where the per-gate computation (which includes the bootstrapping procedure) is O~(\secparam2)
    , {\em independent of L

    }. Security is based on the hardness of RLWE for {\em quasi-polynomial} factors (as opposed to the sub-exponential factors needed in previous schemes).

    We obtain similar results for LWE, but with worse performance. We introduce a number of further optimizations to our schemes. As an example, for circuits of large width -- e.g., where a constant fraction of levels have width at least \secparam
    -- we can reduce the per-gate computation of the bootstrapped version to O~(\secparam), independent of L, by {\em batching the bootstrapping operation}. Previous FHE schemes all required Ω~(\secparam3.5)

    computation per gate.

    At the core of our construction is a much more effective approach for managing the noise level of lattice-based ciphertexts as homomorphic operations are performed, using some new techniques recently introduced by Brakerski and Vaikuntanathan (FOCS 2011).
    
    https://eprint.iacr.org/2011/277

    \item BFV

    In this paper we port Brakerski's fully homomorphic scheme based on the Learning With Errors (LWE) problem to the ring-LWE setting. We introduce two optimised versions of relinearisation that not only result in a smaller relinearisation key, but also faster computations. We provide a detailed, but simple analysis of the various homomorphic operations, such as multiplication, relinearisation and bootstrapping, and derive tight worst case bounds on the noise caused by these operations. The analysis of the bootstrapping step is greatly simplified by using a modulus switching trick. Finally, we derive concrete parameters for which the scheme provides a given level of security and becomes fully homomorphic.

    https://eprint.iacr.org/2012/144

    \if false
    The BFV scheme cannot perform arbitrary computations on encrypted data.
        Instead, each ciphertext has a specific quantity called the `invariant noise
        budget' -- or `noise budget' for short -- measured in bits. The noise budget
        in a freshly encrypted ciphertext (initial noise budget) is determined by
        the encryption parameters. Homomorphic operations consume the noise budget
        at a rate also determined by the encryption parameters. In BFV the two basic
        operations allowed on encrypted data are additions and multiplications, of
        which additions can generally be thought of as being nearly free in terms of
        noise budget consumption compared to multiplications.
    \fi

    % TODO A paper by Costache and Smart [CS16]gives some initial comparisons between BGV, BFV

    \item CKKS

    No está descrito en el estándar, pero sí se implementa en SEAL.

    We suggest a method to construct a homomorphic encryption scheme for approximate arithmetic. It supports an approximate addition and multiplication of encrypted messages, together with a new rescaling procedure for managing the magnitude of plaintext. This procedure truncates a ciphertext into a smaller modulus, which leads to rounding of plaintext. The main idea is to add a noise following significant figures which contain a main message. This noise is originally added to the plaintext for security, but considered to be a part of error occurring during approximate computations that is reduced along with plaintext by rescaling. As a result, our decryption structure outputs an approximate value of plaintext with a predetermined precision.

    We also propose a new batching technique for a RLWE-based construction. A plaintext polynomial is an element of a cyclotomic ring of characteristic zero and it is mapped to a message vector of complex numbers via complex canonical embedding map, which is an isometric ring homomorphism. This transformation does not blow up the size of errors, therefore enables us to preserve the precision of plaintext after encoding. In our construction, the bit size of ciphertext modulus grows linearly with the depth of the circuit being evaluated due to rescaling procedure, while all the previous works either require an exponentially large size of modulus or expensive computations such as bootstrapping or bit extraction. One important feature of our method is that the precision loss during evaluation is bounded by the depth of a circuit and it exceeds at most one more bit compared to unencrypted approximate arithmetic such as floating-point operations. In addition to the basic approximate circuits, we show that our scheme can be applied to the efficient evaluation of transcendental functions such as multiplicative inverse, exponential function, logistic function and discrete Fourier transform.

    https://link.springer.com/chapter/10.1007%2F978-3-319-70694-8_15

\end{itemize}

\subsection{Tercera generación}

\begin{itemize}

  \item GSW

  We describe a comparatively simple fully homomorphic encryption (FHE) scheme based on the learning with errors (LWE) problem. In previous LWE-based FHE schemes, multiplication is a complicated and expensive step involving "relinearization". In this work, we propose a new technique for building FHE schemes that we call the "approximate eigenvector" method. In our scheme, for the most part, homomorphic addition and multiplication are just matrix addition and multiplication. This makes our scheme both asymptotically faster and (we believe) easier to understand.

  In previous schemes, the homomorphic evaluator needs to obtain the user's "evaluation key", which consists of a chain of encrypted secret keys. Our scheme has no evaluation key. The evaluator can do homomorphic operations without knowing the user's public key at all, except for some basic parameters. This fact helps us construct the first identity-based FHE scheme. Using similar techniques, we show how to compile a recent attribute-based encryption scheme for circuits by Gorbunov et al. into an attribute-based FHE scheme that permits data encrypted under the same index to be processed homomorphically.

  https://eprint.iacr.org/2013/340

  \item TFHE

  Basado en una aproximación a LWE conocida como TLWE (Thorus Learn With Errors) en la que los parámetros de LWE se definen sobre un el espacio de un toro \cite{cheon_faster_2016}

  In this paper, we revisit fully homomorphic encryption (FHE) based on GSW and its ring variants. We notice that the internal product of GSW can be replaced by a simpler external product between a GSW and an LWE ciphertext.

  We show that the bootstrapping scheme FHEW of Ducas and Micciancio (Eurocrypt 2015) can be expressed only in terms of this external product. As a result, we obtain a speed up from less than 1 second to less than 0.1 seconds. We also reduce the 1GB bootstrapping key size to 24MB, preserving the same security levels, and we improve the noise propagation overhead by replacing exact decomposition algorithms with approximate ones.

  Moreover, our external product allows to explain the unique asymmetry in the noise propagation of GSW samples and makes it possible to evaluate deterministic automata homomorphically as in (ePrint 2014/283) in an efficient way with a noise overhead only linear in the length of the tested word.

  Finally, we provide an alternative practical analysis of LWE based scheme, which directly relates the security parameter to the error rate of LWE and the entropy of the LWE secret key.

  https://eprint.iacr.org/2016/870

\end{itemize}
