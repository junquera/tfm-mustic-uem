\chapter{Estudio teórico}
\label{chap:teoria}

Para la computación de criptografía homomórfica necesitaremos comprender las bases teóricas matemáticas y los distintos niveles de homomorfismo, además de las herramientas de notación y computación definidas por el estándar...

\section{Tipos}

Las generaciones publicadas por el estándar guardan una estrecha relación con las capacidades que tienen los esquemas para trabajar con los datos cifrados. Estas capacidades que van desde la posibilidad de aplicar algún homomorfismo a poder trabajar libremente con el texto cifrado están categorizadas en tres niveles. Para comenzar, veremos cuales son estos tres tipos:

\begin{itemize}
  \item Partially Homomorphic Encryption
  \item Somewhat Homomorphic Encryption (SHE)
  \item Fully Homormorphic Encryption (FHE)
\end{itemize}

Más adelante veremos qué esquemas concretos existen, y a qué tipo pertenecerán.

\section{Primitivas matemáticas}

La seguridad de los sistemas criptográficos se basa en problemas matemáticos que, si bien pueden ser resolubles, dicha resolución no es computacionalmente viable en un tiempo razonable: factorización de enteros, logaritmo discreto, ordenación de conjuntos...

La base de los principales sistemas de criptografía homomórfica modernos son problemas relacionados con unas estructuras algebraicas conocidas como retículos.

\subsection{Lattice-based encryption}

Un retículo o red (también conocidos como lattice en inglés) es un conjuntos de elementos similar a un espacio vectorial discreto generado por la combinación de una base vectorial concreta.

Por ejemplo, a los vectores $u = (2, 0)$ y $v = (-1, 3)$ serían la base de la red bidimensional generada por todas sus combinaciones $n*u + m*v$ (ver \ref{fig:lattice1}).

\begin{figure}[h]
  \caption{Espacio vectorial generado por u y v}
  \label{fig:lattice1}
  \includegraphics[]{lattice1}
\end{figure}

Es decir, el conjunto de puntos del gráfico \ref{fig:lattice1} sería un retículo, cuya base está formada por los vectores $u$ y $v$.

En función de lo cerca o lejos que estén los vectores que forman la base del origen se dirá que estas bases son largas o cortas\cite{wickr_what_2018}. Por ejemplo, el espacio anterior podría formarse con el mismo vector $v$, y con otro vector $w = (1, 0)$ más corto que $u$.

En la búsqueda de soluciones criptográficas resistentes a la computación cuántica se han encontrado útiles los siguientes problemas de retículos:

\begin{itemize}
  \item Short Vector Problem (SVP)

  Consiste en dada una base larga, buscar un vector corto lo más cercano al origen, sin ser el origen mismo (ver \ref{fig:svp}).

  \begin{figure}[h]
    \caption{Short vector problem \cite{noauthor_lattice_2019}}
    \label{fig:svp}
    \includegraphics[]{svp}
  \end{figure}

  \item Short Basis Problem (SBP)

  Dada una base larga buscar una base corta del mismo espacio.

  \item Closest Vector Problem (CVP)

  Dada una base larga y un punto $P$ de la red, buscar el vector de la red formada por la base más cercano a $P$ (ver \ref{fig:cvp}).

  \begin{figure}[h]
    \caption{Closest vector problem \cite{noauthor_lattice_2019}}
    \label{fig:cvp}
    \includegraphics[]{cvp}
  \end{figure}


\end{itemize}

Aunque estos problemas puedan parecer triviales a simple vista, su complejidad computacional aumenta exponencialmente con el aumento del número de dimensiones hasta hacerlo computacionalmente irresoluble.

Llamaremos Lattice-based encryption (para ajustarnos a la bibliografía, que está en su práctica totalidad escrita en inglés) a la aplicación de este conjunto de problemas a la criptografía.

En cuanto a nuestro caso, el problema del aprendizaje con errores aplicado a retículos será el núcleo de la criptografía homomórfica.

\subsection{Learn With Errors (LWE)}

El problema del aprendizaje con errores plantea la dificultad de determinar los componentes de una función en base a sus resultados cuando estos contienen errores\cite{apon_intro_nodate}.

Dada una base modular $q$, n vectores $a_i \leftarrow \mathbbb{Z}^m_q$, un vector $s \leftarrow \mathbbb{Z}^n_q$ y $n$ vectores $ e_i \leftarrow \chi{}^m $ tomados de una distribución de error (distribución de Gauss\cite{noauthor_generalized_2019}) \chi{} \subset{} \mathbbb{Z}:

\begin{gather}
    \label{form:gen_lwe}
    b_i = (a_i \times s + e_i) \Mod{q}
\end{gather}

Conociendo $m$ pares $(a_i, b_i)$ no se puede determinar el valor $s$, y no se pueden diferenciar dichos pares de una distribución aleatoria\cite{t._zijlstra_learning_nodate}.

\subsubsection{Uso en criptografía}

En su estudio, Regev\cite{regev_learning_2010} formula un sistema de clave pública utilizando este problema:

\begin{enumerate}
  \item Generación de clave Pública

  Se emite como clave pública una colección de valores $(ai, bi)$ generada como hemos visto en \ref{form:gen_lwe}. El conjunto de vectores $a_i$ se interpretará en algunas implementaciones como una matriz $A \leftarrow \mathbbb{Z}_q^{m \times n}$.

    \begin{figure}[h]
      \caption{LWE \cite{halevi_homomorphic_2017}}
      \label{fig:lwe}
      \includegraphics[width=\textwidth]{lwe}
    \end{figure}

  \item Cifrado

  Para cada bit $x$ a cifrar se elige una de las parejas y se realiza la siguiente operación:

    \begin{gather*}
        \label{form:cifrado_lwe}
        (c1, c2) = (\sum_{j=1}^{m} a_i_j, \sum_{j=1}^{m} b_i_j + x * (q/2))
    \end{gather*}

  \item Descifrado

  El resultado realmente no es determinista, es decir, no devuelve realmente el valor cifrado. Para determinar el valor calcularíamos:

    \begin{gather*}
        \label{form:descifrado_lwe}
        x \approx c_2 - (c_1*s) \\
        b + x*(q/2) - a*s \\
        a*s + e + x*(q/2) - a*s \\
        e + x*(q/2) \approx x * (q/2)
    \end{gather*}

  Si se ha introducido $s$ correctamente, y siendo $e$ despreciable en comparación con $ q/2 $, obtendríamos como resultado $ x * (q/2) $, por lo que sabremos que $ x = 1$ si el resultado es cercano a $ q/2 $ y  $ x = 0 $ si el resultado es cercano a $ 0 $.

\end{enumerate}

En el apéndice \ref{apendix:test_lwe.py} puede verse un ejemplo de implementación del algoritmo, y el resultado de su ejecución.

\section{Generaciones}

En base a los encuentros del estándar ...

La primera generación ...

En la segunda se asientan los modelos SHE que permiten el cálculo de variables acotadas. Estos cálculos ya son fully homomorphic (suma y multi), pero a medida que se opera con las variables va aumentando un nivel de error que hace que sea imposible seguir calculando y obtener resultados válidos. A esta generación pertenecen los esquemas BGV, BFV y CKKS. Estos dos últimos están implementados en la librería SEAL.

La tercera y última generación ya es considerada FHE, pues permite, gracias al esquema GSW, realizar infinitas operaciones sin perder precisión. Para el desarrollo de este tercer estándar usaremos TFHE.

\subsection{Pre-HE}

Dentro de la categoría de esquemas previos a la criptografía homomórfica se encuentran aquellos que, o bien tienen propiedades homomórficas de forma casual, o bien no cumplen las condiciones necesarias para que se puedan utilizar en ningún sistema. Hablaremos de RSA por lo intuitivo que es para comprender la criptografía homomórfica, y del sistema desarrollado por Boneh, Goh y Nissim por ser uno de los primeros orientados correctamente a la computación con criptografía homomórfica.

\begin{itemize}

    \item RSA
    
    Las propiedades matemáticas de RSA lo convierten en un esquema con homomorfismo en el producto. Para cifrar y descifrar, en RSA se exponencia el elemento al que se le desea aplicar la operación. Siendo $e$ la clave de cifrado y $d$ la clave de descifrado, la aplicación de RSA (puro) sobre el mensaje $m$ sería tal que:
    
    \begin{gather*}
        c = m^e \Mod{n} \\
        m = c^d \Mod{n}
    \end{gather*}
    
    Esto hace que, si multiplicamos dos mensajes cifrados:
    
    \begin{gather*}
        c_1 = m_1^e \Mod{n}, c_2 = m_2^e \Mod{n} \\
        c_1 * c_2 = m_1^e * m_2^e \Mod{n} = (m_1*m_2)^e \Mod{n} 
    \end{gather*}
    
    Podamos obtener el producto de los dos elementos al descifrar:
    
    \begin{gather*}
        (m_1^e * m_2^e)^d \Mod{n} \\
        ((m_1*m_2)^e)^d \Mod{n} \\
        m_1 * m_2
    \end{gather*}
    
    \item Criptosistema de Boneh–Goh–Nissim 
    
    Unlimited number of addition operations but at most one multiplication. 
    
    https://crypto.stanford.edu/~dabo/pubs/papers/2dnf.pdf
    
\end{itemize}

\subsection{Primera generación}

\begin{itemize}
    \item Fully homomorphic encryption using ideal lattices
    
    https://www.cs.cmu.edu/~odonnell/hits09/gentry-homomorphic-encryption.pdf
\end{itemize}

\subsection{Segunda generación}

\begin{itemize}
    \item BGV
    
    https://eprint.iacr.org/2011/277

    \item BFV
    
    https://eprint.iacr.org/2012/144

    \if false
    The BFV scheme cannot perform arbitrary computations on encrypted data.
        Instead, each ciphertext has a specific quantity called the `invariant noise
        budget' -- or `noise budget' for short -- measured in bits. The noise budget
        in a freshly encrypted ciphertext (initial noise budget) is determined by
        the encryption parameters. Homomorphic operations consume the noise budget
        at a rate also determined by the encryption parameters. In BFV the two basic
        operations allowed on encrypted data are additions and multiplications, of
        which additions can generally be thought of as being nearly free in terms of
        noise budget consumption compared to multiplications.
    \fi
    
    % TODO A paper by Costache and Smart [CS16]gives some initial comparisons between BGV, BFV

    \item CKKS
    
    No está descrito en el estándar, pero sí se implementa en SEAL.

    https://link.springer.com/chapter/10.1007%2F978-3-319-70694-8_15
    
\end{itemize}

Además aparecen una técnica interesante:

\begin{itemize}
    \item Bootstraping
    % https://link.springer.com/chapter/10.1007/978-3-642-30057-8_1
\end{itemize}

\subsection{Tercera generación}

- GSW

https://eprint.iacr.org/2013/340

- TFHE

https://eprint.iacr.org/2016/870.pdf